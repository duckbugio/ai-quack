# TODO: Разработка веб-игры "Утка" (Flappy Bird Clone)

## Стек технологий

### Основные технологии:
- **React 18+** - UI библиотека для создания компонентов
- **TypeScript 5+** - Типизированный JavaScript для надежности кода
- **Vite** - Современный сборщик для быстрой разработки
- **Canvas API** - Рендеринг игровой графики и анимаций
- **CSS Modules** - Стилизация компонентов

### Дополнительные инструменты:
- **ESLint** - Линтинг кода
- **Prettier** - Форматирование кода
- **React Testing Library** - Тестирование компонентов (опционально)

---

## Этап 1: Инициализация проекта и настройка окружения

### 1.1 Создание проекта
- [ ] Инициализировать React + TypeScript проект через Vite
  - Команда: `npm create vite@latest duck-game -- --template react-ts`
  - Перейти в директорию проекта
  - Установить зависимости: `npm install`

### 1.2 Настройка структуры проекта
- [ ] Создать структуру директорий:
  ```
  /src
    /components      - React компоненты
      /Game          - Основной игровой компонент
      /UI            - UI компоненты (кнопки, меню)
    /game            - Игровая логика
      /entities      - Игровые сущности (Утка, Препятствия)
      /systems       - Игровые системы (физика, коллизии)
      /utils         - Утилиты (константы, хелперы)
    /assets          - Ресурсы (изображения, звуки)
      /images
      /sounds
    /hooks           - Кастомные React хуки
    /types           - TypeScript типы и интерфейсы
    /styles          - Глобальные стили
  ```

### 1.3 Настройка инструментов разработки
- [ ] Настроить ESLint конфигурацию
  - Установить: `npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin`
  - Создать `.eslintrc.json` с правилами для React и TypeScript
- [ ] Настроить Prettier
  - Установить: `npm install -D prettier`
  - Создать `.prettierrc` с настройками форматирования
- [ ] Настроить `.gitignore` для исключения node_modules, dist, и т.д.

### 1.4 Настройка базовых типов
- [ ] Создать файл `src/types/game.types.ts` с базовыми типами:
  - `GameState` - состояние игры (MENU, PLAYING, PAUSED, GAME_OVER)
  - `Position` - интерфейс для координат {x: number, y: number}
  - `Velocity` - интерфейс для скорости {vx: number, vy: number}
  - `GameConfig` - конфигурация игры (гравитация, скорость, размеры)

---

## Этап 2: Создание базовой структуры игры

### 2.1 Создание игрового Canvas компонента
- [ ] Создать компонент `src/components/Game/GameCanvas.tsx`
  - Использовать `useRef` для получения ссылки на canvas элемент
  - Настроить размеры canvas (например, 800x600px)
  - Реализовать базовую структуру компонента с TypeScript типами
  - Добавить обработку изменения размера окна (responsive)

### 2.2 Создание игрового цикла
- [ ] Создать хук `src/hooks/useGameLoop.ts`
  - Использовать `requestAnimationFrame` для игрового цикла
  - Реализовать функцию обновления состояния игры (update)
  - Реализовать функцию отрисовки (render)
  - Управление жизненным циклом (start, stop, pause)
  - Оптимизация производительности (throttling при необходимости)

### 2.3 Создание системы управления состоянием игры
- [ ] Создать контекст `src/contexts/GameContext.tsx`
  - Состояние игры (GameState)
  - Счет (score)
  - Лучший результат (highScore) с сохранением в localStorage
  - Функции для изменения состояния (startGame, pauseGame, gameOver, resetGame)

### 2.4 Создание констант игры
- [ ] Создать файл `src/game/utils/constants.ts`
  - Константы размеров (CANVAS_WIDTH, CANVAS_HEIGHT)
  - Физические константы (GRAVITY, JUMP_FORCE)
  - Скорости движения (GROUND_SPEED, OBSTACLE_SPEED)
  - Размеры объектов (DUCK_WIDTH, DUCK_HEIGHT, PIPE_WIDTH, PIPE_HEIGHT)
  - Расстояния между препятствиями (PIPE_GAP, PIPE_SPACING)

---

## Этап 3: Реализация главного персонажа - Утка

### 3.1 Создание класса Утки
- [ ] Создать файл `src/game/entities/Duck.ts`
  - Класс `Duck` с полями: position, velocity, width, height
  - Метод `update(deltaTime)` - обновление позиции с учетом гравитации
  - Метод `jump()` - прыжок (изменение вертикальной скорости)
  - Метод `draw(ctx: CanvasRenderingContext2D)` - отрисовка утки
  - Метод `getBounds()` - получение границ для коллизий

### 3.2 Визуализация Утки
- [ ] Создать простую графику утки (можно начать с прямоугольника/эллипса)
- [ ] Реализовать анимацию крыльев:
  - Состояние крыльев (вверх/вниз)
  - Переключение состояния при каждом прыжке
  - Визуальное отображение крыльев на canvas
- [ ] Добавить спрайты утки (опционально):
  - Загрузить изображения утки в разных состояниях
  - Реализовать систему спрайтов для анимации

### 3.3 Физика движения Утки
- [ ] Реализовать гравитацию:
  - Постоянное ускорение вниз
  - Ограничение максимальной скорости падения
- [ ] Реализовать прыжок:
  - Мгновенное изменение скорости вверх при нажатии
  - Плавное замедление под действием гравитации
- [ ] Добавить границы экрана:
  - Утка не может выйти за верхнюю и нижнюю границы canvas
  - При достижении границ - игра окончена

### 3.4 Управление Уткой
- [ ] Добавить обработку клавиатуры:
  - Пробел или стрелка вверх для прыжка
  - Использовать `useEffect` для подписки на события клавиатуры
- [ ] Добавить обработку мыши/тача:
  - Клик/тап для прыжка
  - Поддержка мобильных устройств

---

## Этап 4: Реализация препятствий (трубы/преграды)

### 4.1 Создание класса Препятствия
- [ ] Создать файл `src/game/entities/Obstacle.ts`
  - Класс `Obstacle` с полями: x, topHeight, bottomHeight, width, gap
  - Метод `update(deltaTime)` - движение препятствия влево
  - Метод `draw(ctx: CanvasRenderingContext2D)` - отрисовка верхней и нижней части
  - Метод `getBounds()` - получение границ для коллизий
  - Метод `isOffScreen()` - проверка, вышло ли препятствие за экран

### 4.2 Система генерации препятствий
- [ ] Создать файл `src/game/systems/ObstacleManager.ts`
  - Класс `ObstacleManager` для управления препятствиями
  - Метод `spawnObstacle()` - создание нового препятствия
  - Метод `update(deltaTime)` - обновление всех препятствий
  - Метод `removeOffScreen()` - удаление препятствий за экраном
  - Автоматическая генерация препятствий через определенные интервалы
  - Случайная высота препятствий (с ограничениями)

### 4.3 Визуализация препятствий
- [ ] Реализовать отрисовку препятствий:
  - Верхняя часть (от верха до начала gap)
  - Нижняя часть (от конца gap до низа)
  - Использовать простые формы (прямоугольники) или спрайты
- [ ] Добавить визуальные эффекты:
  - Градиенты или текстуры
  - Тени для глубины

---

## Этап 5: Система коллизий

### 5.1 Реализация детекции коллизий
- [ ] Создать файл `src/game/systems/CollisionSystem.ts`
  - Функция `checkCollision(rect1, rect2)` - проверка пересечения прямоугольников
  - Функция `checkDuckObstacleCollision(duck, obstacle)` - проверка коллизии утки с препятствием
  - Функция `checkDuckBoundsCollision(duck, canvas)` - проверка выхода за границы

### 5.2 Интеграция коллизий в игровой цикл
- [ ] Добавить проверку коллизий в каждый кадр игры
- [ ] При обнаружении коллизии:
  - Остановить игру
  - Перевести состояние в GAME_OVER
  - Показать экран окончания игры

### 5.3 Оптимизация коллизий
- [ ] Использовать пространственное разделение (spatial partitioning) при необходимости
- [ ] Проверять коллизии только с видимыми препятствиями
- [ ] Оптимизировать вычисления границ объектов

---

## Этап 6: Система подсчета очков

### 6.1 Логика подсчета очков
- [ ] Создать файл `src/game/systems/ScoreSystem.ts`
  - Отслеживание прохождения препятствий
  - Начисление очков за каждое пройденное препятствие
  - Увеличение сложности с ростом счета (опционально)

### 6.2 Отображение счета
- [ ] Добавить отрисовку счета на canvas:
  - Текущий счет в верхней части экрана
  - Стилизованный шрифт
  - Анимация при изменении счета (опционально)

### 6.3 Сохранение лучшего результата
- [ ] Реализовать сохранение лучшего результата в localStorage
  - Проверка при окончании игры
  - Обновление лучшего результата при необходимости
  - Отображение лучшего результата в меню и во время игры

---

## Этап 7: Фон и окружение

### 7.1 Создание фона
- [ ] Реализовать отрисовку фона:
  - Небо (градиент или изображение)
  - Облака (статичные или движущиеся)
  - Параллакс эффект для глубины (опционально)

### 7.2 Создание земли
- [ ] Реализовать отрисовку земли:
  - Линия или полоса внизу экрана
  - Текстура травы (опционально)
  - Анимация движения для эффекта прокрутки

### 7.3 Декоративные элементы
- [ ] Добавить декоративные элементы:
  - Деревья на заднем плане
  - Птицы (не интерактивные)
  - Другие элементы для атмосферы

---

## Этап 8: UI компоненты и меню

### 8.1 Главное меню
- [ ] Создать компонент `src/components/UI/MainMenu.tsx`
  - Заголовок игры
  - Кнопка "Начать игру"
  - Отображение лучшего результата
  - Инструкции по управлению

### 8.2 Экран паузы
- [ ] Создать компонент `src/components/UI/PauseMenu.tsx`
  - Кнопка "Продолжить"
  - Кнопка "В главное меню"
  - Затемнение фона при паузе

### 8.3 Экран окончания игры
- [ ] Создать компонент `src/components/UI/GameOverMenu.tsx`
  - Отображение финального счета
  - Отображение лучшего результата
  - Кнопка "Играть снова"
  - Кнопка "В главное меню"
  - Анимация появления (опционально)

### 8.4 Стилизация UI
- [ ] Создать стили для всех UI компонентов:
  - Современный дизайн
  - Анимации при наведении
  - Адаптивность для мобильных устройств
  - Использование CSS Modules

---

## Этап 9: Звуковые эффекты и музыка

### 9.1 Подготовка звуковых файлов
- [ ] Найти или создать звуковые эффекты:
  - Звук прыжка утки
  - Звук столкновения
  - Звук набора очков
  - Фоновая музыка (опционально)

### 9.2 Интеграция звуков
- [ ] Создать файл `src/game/utils/SoundManager.ts`
  - Класс для управления звуками
  - Методы для воспроизведения звуков
  - Управление громкостью
  - Кэширование звуковых файлов

### 9.3 Добавление звуков в игру
- [ ] Воспроизведение звука прыжка при нажатии
- [ ] Воспроизведение звука при столкновении
- [ ] Воспроизведение звука при наборе очков
- [ ] Добавить настройку включения/выключения звуков в меню

---

## Этап 10: Оптимизация и полировка

### 10.1 Оптимизация производительности
- [ ] Оптимизировать отрисовку:
  - Отрисовывать только видимые объекты
  - Использовать requestAnimationFrame эффективно
  - Минимизировать перерисовки
- [ ] Оптимизировать память:
  - Правильно удалять объекты при выходе за экран
  - Избегать утечек памяти в игровом цикле

### 10.2 Улучшение игрового процесса
- [ ] Настроить баланс сложности:
  - Скорость препятствий
  - Расстояние между препятствиями
  - Высота gap между препятствиями
- [ ] Добавить прогрессивное увеличение сложности:
  - Увеличение скорости со временем
  - Уменьшение расстояний между препятствиями

### 10.3 Анимации и эффекты
- [ ] Добавить плавные переходы между состояниями
- [ ] Добавить эффекты частиц при столкновении (опционально)
- [ ] Улучшить анимацию утки (более плавные движения)

### 10.4 Адаптивность
- [ ] Обеспечить работу на разных размерах экрана:
  - Масштабирование canvas
  - Адаптивные размеры элементов
  - Поддержка мобильных устройств (touch events)

---

## Этап 11: Тестирование

### 11.1 Функциональное тестирование
- [ ] Протестировать все игровые механики:
  - Движение утки
  - Генерация препятствий
  - Коллизии
  - Подсчет очков
  - Сохранение лучшего результата

### 11.2 Тестирование на разных устройствах
- [ ] Протестировать на десктопе (разные браузеры)
- [ ] Протестировать на мобильных устройствах
- [ ] Проверить производительность на слабых устройствах

### 11.3 Исправление багов
- [ ] Исправить найденные ошибки
- [ ] Оптимизировать проблемные участки кода

---

## Этап 12: Финальная полировка и документация

### 12.1 Документация кода
- [ ] Добавить JSDoc комментарии к основным функциям и классам
- [ ] Описать архитектуру проекта в README.md
- [ ] Добавить инструкции по запуску и сборке

### 12.2 README.md
- [ ] Создать подробный README.md с:
  - Описанием проекта
  - Инструкциями по установке
  - Инструкциями по запуску
  - Описанием управления
  - Скриншотами игры
  - Информацией о технологиях

### 12.3 Финальная проверка
- [ ] Проверить все чекбоксы в этом TODO
- [ ] Убедиться, что код чистый и читаемый
- [ ] Проверить отсутствие console.log в production коде
- [ ] Оптимизировать размер bundle (если необходимо)

---

## Дополнительные улучшения (опционально)

### Дополнительные функции:
- [ ] Добавить разные темы оформления (день/ночь)
- [ ] Добавить систему достижений
- [ ] Добавить таблицу лидеров (с использованием backend)
- [ ] Добавить разные персонажи на выбор
- [ ] Добавить power-ups (временные улучшения)
- [ ] Добавить режим "выживание" с бесконечной сложностью

---

## Примечания по разработке

### Рекомендации:
1. Начинать с простых форм (прямоугольники) для быстрого прототипирования
2. Постепенно улучшать визуальную часть после реализации логики
3. Регулярно тестировать игру в процессе разработки
4. Использовать Git для версионирования с осмысленными коммитами
5. Разбивать задачи на небольшие, выполнимые части

### Важные моменты:
- Игровой цикл должен работать стабильно на 60 FPS
- Коллизии должны быть точными и отзывчивыми
- Управление должно быть мгновенным и предсказуемым
- UI должен быть интуитивно понятным

---

**Дата создания:** [Текущая дата]
**Статус:** В разработке
**Приоритет:** Высокий
